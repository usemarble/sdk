import { createHmac, timingSafeEqual } from "node:crypto";
import { isRecord, toDateStrict } from "./utils";

/**
 * Envelope for a Marble webhook event.
 * Use {@link parseWebhookEvent} to safely parse and map the payload.
 */
export type WebhookEvent<T = unknown> = {
  /** Event id generated by the server. */
  id: string;
  /** Event type (e.g. `"post.published"`). */
  type: string;
  /** Creation timestamp (parsed to `Date`). */
  createdAt: Date;
  /** Event-specific payload. */
  data: T;
};

/**
 * Headers sent by Marble webhooks.
 * - `x-marble-signature`: either a raw hex HMAC, or `t=<unixSeconds>,v1=<hex>`
 * - `x-marble-timestamp`: optional; when present, signatures typically use `${t}.${rawBody}`
 */
export type WebhookHeaders = {
  /** HMAC-SHA256 payload signature. */
  "x-marble-signature": string;
  /** UNIX seconds or an ISO timestamp (optional). */
  "x-marble-timestamp"?: string;
} & Record<string, string>;

/** Options that affect webhook signature verification. */
export type VerifyOptions = {
  /**
   * When `true`, the signed payload is `${timestamp}.${rawBody}`.
   * When `false`, the signed payload is `rawBody`.
   * Default: inferred from the presence of a timestamp header.
   */
  includeTimestampInPayload?: boolean;
  /**
   * Acceptable clock skew (in seconds) when verifying timestamped signatures.
   * Use `0` to disable the freshness check. Default: `300` (5 minutes).
   */
  toleranceSeconds?: number;
};

/** @internal Compute HMAC-SHA256 over the provided payload using the secret. */
function computeSignature(secret: string, signedPayload: string): Buffer {
  const h = createHmac("sha256", secret);
  h.update(signedPayload, "utf8");
  return Buffer.from(h.digest("hex"), "hex");
}

/**
 * @internal Parse signature header value.
 * Accepts either:
 *  - a raw hex string, or
 *  - `"t=<timestamp>,v1=<hex>"`
 */
function parseProvidedSignature(sigHeader: string): {
  ts?: string;
  sigHex: string;
} {
  if (sigHeader.includes(",")) {
    const parts = sigHeader.split(",").map((s) => s.trim());
    let ts: string | undefined;
    let sigHex = "";
    for (const p of parts) {
      if (p.startsWith("t=")) ts = p.slice(2);
      if (p.startsWith("v1=")) sigHex = p.slice(3);
    }
    return ts !== undefined ? { ts, sigHex } : { sigHex };
  }
  return { sigHex: sigHeader };
}

/**
 * Verify a Marble webhook signature (HMAC-SHA256).
 *
 * - If a timestamp is present (or `includeTimestampInPayload` is `true`),
 *   the function signs `${timestamp}.${rawBody}` instead of `rawBody` alone.
 * - When timestamped, a freshness check is applied using `toleranceSeconds`.
 *
 * @param rawBody Raw request body **as received** (do not JSON.parse it first).
 * @param headers Request headers containing `x-marble-signature` (and optionally `x-marble-timestamp`).
 * @param secret Shared signing secret.
 * @param opts Verification options (timestamp behavior, tolerance).
 * @returns `true` if verification succeeds; otherwise throws an `Error`.
 * @throws If signature is missing/invalid or timestamp is outside tolerance.
 *
 * @remarks
 * This implementation uses Node's `crypto` module and is intended for server runtimes.
 * For edge/browser runtimes, use Web Crypto (SubtleCrypto) and adapt accordingly.
 */
export function verifyMarbleSignature(
  rawBody: string,
  headers: WebhookHeaders,
  secret: string,
  opts: VerifyOptions = {}
): true {
  const sigHeader = headers["x-marble-signature"];
  if (!sigHeader) throw new Error("Missing x-marble-signature header");

  const { ts, sigHex } = parseProvidedSignature(sigHeader);
  const timestampHeader = headers["x-marble-timestamp"] ?? ts;

  const includeTs = opts.includeTimestampInPayload ?? Boolean(timestampHeader);
  const tolerance = Math.max(0, opts.toleranceSeconds ?? 300);

  let signedPayload = rawBody;
  if (includeTs) {
    const t = timestampHeader ?? "";
    if (!t) throw new Error("Timestamp required for timestamped signatures");
    signedPayload = `${t}.${rawBody}`;

    // Freshness check (optional)
    if (tolerance > 0) {
      const tsDate = Number.isFinite(Number(t))
        ? new Date(Number(t) * 1000)
        : new Date(t);
      const tsMs = tsDate.getTime();
      if (Number.isNaN(tsMs)) {
        throw new Error("Invalid timestamp format");
      }
      const skew = Math.abs(Date.now() - tsMs);
      if (skew > tolerance * 1000) {
        throw new Error("Timestamp outside tolerance window");
      }
    }
  }

  const expected = computeSignature(secret, signedPayload);
  const provided = Buffer.from(sigHex, "hex");
  if (
    expected.length !== provided.length ||
    !timingSafeEqual(expected, provided)
  ) {
    throw new Error("Invalid webhook signature");
  }
  return true;
}

/**
 * Parse a webhook JSON body into a typed {@link WebhookEvent}.
 *
 * @typeParam T - The desired type of the `data` payload after mapping.
 * @param jsonBody Raw JSON string of the webhook body.
 * @param mapData A mapper that converts/validates the unknown `data` into your type `T`.
 *
 * @example
 * ```ts
 * type PostCreated = { id: string };
 * const evt = parseWebhookEvent<PostCreated>(rawJson, (u) => {
 *   if (!u || typeof (u as any).id !== "string") throw new Error("bad data");
 *   return u as PostCreated;
 * });
 * console.log(evt.type, evt.data.id);
 * ```
 */
export function parseWebhookEvent<T>(
  jsonBody: string,
  mapData: (u: unknown) => T
): WebhookEvent<T> {
  const parsed = JSON.parse(jsonBody) as unknown;
  if (!isRecord(parsed)) throw new Error("Invalid webhook envelope");

  const id = String(parsed["id"] ?? "");
  const type = String(parsed["type"] ?? "");
  const createdAt = toDateStrict(parsed["createdAt"], "createdAt");
  const dataUnknown = parsed["data"];

  return {
    id,
    type,
    createdAt,
    data: mapData(dataUnknown),
  };
}
