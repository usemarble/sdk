import { createHmac, timingSafeEqual } from "node:crypto";
import { isRecord, toDateStrict } from "./utils";

/**
 * Envelope for a Marble webhook event.
 * Use {@link parseWebhookEvent} to safely parse and map the payload.
 */
export type WebhookEvent<T = unknown> = {
	/** Event id generated by the server. */
	id: string;
	/** Event type (e.g. `"post.published"`). */
	type: string;
	/** Creation timestamp (parsed to `Date`). */
	createdAt: Date;
	/** Event-specific payload. */
	data: T;
};

/**
 * Headers sent by Marble webhooks.
 * - `x-marble-signature`: either a raw hex HMAC, or `t=<unixSeconds>,v1=<hex>`
 * - `x-marble-timestamp`: optional; when present, signatures typically use `${t}.${rawBody}`
 */
export type WebhookHeaders = {
	/** HMAC-SHA256 payload signature. */
	"x-marble-signature": string;
	/** UNIX seconds or an ISO timestamp (optional). */
	"x-marble-timestamp"?: string;
} & Record<string, string>;

/** Options that affect webhook signature verification. */
export type VerifyOptions = {
	/**
	 * When `true`, the signed payload is `${timestamp}.${rawBody}`.
	 * When `false`, the signed payload is `rawBody`.
	 * Default: inferred from the presence of a timestamp header.
	 */
	includeTimestampInPayload?: boolean;
	/**
	 * Acceptable clock skew (in seconds) when verifying timestamped signatures.
	 * Use `0` to disable the freshness check. Default: `300` (5 minutes).
	 */
	toleranceSeconds?: number;
};

/** @internal Compute HMAC-SHA256 over the provided payload using the secret. */
function computeSignature(secret: string, signedPayload: string): Buffer {
	const h = createHmac("sha256", secret);
	h.update(signedPayload, "utf8");
	return Buffer.from(h.digest("hex"), "hex");
}

/**
 * @internal Parse signature header value.
 * Accepts either:
 *  - a raw hex string, or
 *  - `"t=<timestamp>,v1=<hex>"`
 */
function parseProvidedSignature(sigHeader: string): {
	ts?: string;
	sigHex: string;
} {
	if (sigHeader.includes(",")) {
		const parts = sigHeader.split(",").map((s) => s.trim());
		let ts: string | undefined;
		let sigHex = "";
		for (const p of parts) {
			if (p.startsWith("t=")) ts = p.slice(2);
			if (p.startsWith("v1=")) sigHex = p.slice(3);
		}
		return ts !== undefined ? { ts, sigHex } : { sigHex };
	}
	return { sigHex: sigHeader };
}

/**
 * Verify a Marble webhook signature (HMAC-SHA256).
 *
 * - If a timestamp is present (or `includeTimestampInPayload` is `true`),
 *   the function signs `${timestamp}.${rawBody}` instead of `rawBody` alone.
 * - When timestamped, a freshness check is applied using `toleranceSeconds`.
 *
 * @param rawBody Raw request body **as received** (do not JSON.parse it first).
 * @param headers Request headers containing `x-marble-signature` (and optionally `x-marble-timestamp`).
 * @param secret Shared signing secret.
 * @param opts Verification options (timestamp behavior, tolerance).
 * @returns `true` if verification succeeds; otherwise throws an `Error`.
 * @throws If signature is missing/invalid or timestamp is outside tolerance.
 *
 * @remarks
 * This implementation uses Node's `crypto` module and is intended for server runtimes.
 * For edge/browser runtimes, use Web Crypto (SubtleCrypto) and adapt accordingly.
 */
export function verifyMarbleSignature(
	rawBody: string,
	headers: WebhookHeaders,
	secret: string,
	opts: VerifyOptions = {},
): true {
	const sigHeader = headers["x-marble-signature"];
	if (!sigHeader) throw new Error("Missing x-marble-signature header");

	const { ts, sigHex } = parseProvidedSignature(sigHeader);
	const timestampHeader = headers["x-marble-timestamp"] ?? ts;

	const includeTs = opts.includeTimestampInPayload ?? Boolean(timestampHeader);
	const tolerance = Math.max(0, opts.toleranceSeconds ?? 300);

	let signedPayload = rawBody;
	if (includeTs) {
		const t = timestampHeader ?? "";
		if (!t) throw new Error("Timestamp required for timestamped signatures");
		signedPayload = `${t}.${rawBody}`;

		// Freshness check (optional)
		if (tolerance > 0) {
			const tsDate = Number.isFinite(Number(t))
				? new Date(Number(t) * 1000)
				: new Date(t);
			const tsMs = tsDate.getTime();
			if (Number.isNaN(tsMs)) {
				throw new Error("Invalid timestamp format");
			}
			const skew = Math.abs(Date.now() - tsMs);
			if (skew > tolerance * 1000) {
				throw new Error("Timestamp outside tolerance window");
			}
		}
	}

	const expected = computeSignature(secret, signedPayload);
	const provided = Buffer.from(sigHex, "hex");
	if (
		expected.length !== provided.length ||
		!timingSafeEqual(expected, provided)
	) {
		throw new Error("Invalid webhook signature");
	}
	return true;
}

/**
 * Parse a webhook JSON body into a typed {@link WebhookEvent}.
 *
 * @typeParam T - The desired type of the `data` payload after mapping.
 * @param jsonBody Raw JSON string of the webhook body.
 * @param mapData A mapper that converts/validates the unknown `data` into your type `T`.
 *
 * @example
 * ```ts
 * type PostCreated = { id: string };
 * const evt = parseWebhookEvent<PostCreated>(rawJson, (u) => {
 *   if (!u || typeof (u as any).id !== "string") throw new Error("bad data");
 *   return u as PostCreated;
 * });
 * console.log(evt.type, evt.data.id);
 * ```
 */
export function parseWebhookEvent<T>(
	jsonBody: string,
	mapData: (u: unknown) => T,
): WebhookEvent<T> {
	const parsed = JSON.parse(jsonBody) as unknown;
	if (!isRecord(parsed)) throw new Error("Invalid webhook envelope");

	const id = String(parsed["id"] ?? "");
	const type = String(parsed["type"] ?? "");
	const createdAt = toDateStrict(parsed["createdAt"], "createdAt");
	const dataUnknown = parsed["data"];

	return {
		id,
		type,
		createdAt,
		data: mapData(dataUnknown),
	};
}
